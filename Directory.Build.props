<Project>

	<!--
	Default properties:
	-->

	<PropertyGroup>
		<Product>neonSDK</Product>
		<Authors>neonFORGE Team</Authors>
		<Company>neonFORGE LLC</Company>
		<Copyright>Copyright Â© 2005-2022 by neonFORGE LLC.  All rights reserved.</Copyright>
		<GenerateDocumentationFile>true</GenerateDocumentationFile>
		<LangVersion>latest</LangVersion>
		<Nullable>disable</Nullable>
		<EnableNETAnalyzers>true</EnableNETAnalyzers>
		<TargetLatestRuntimePatch>true</TargetLatestRuntimePatch>
		<PackageRequireLicenseAcceptance>true</PackageRequireLicenseAcceptance>
		<WarningsAsErrors>NU1605</WarningsAsErrors>
		<TreatWarningsAsErrors>false</TreatWarningsAsErrors>
		<ImplicitUsings>disable</ImplicitUsings>
		<NoWarn>1701;1702;NETSDK1138;CS8892;IDE0063</NoWarn>

		<!-- Debugging -->

		<DebugType>embedded</DebugType>
		<PublishRepositoryUrl>true</PublishRepositoryUrl>
		<EmbedUntrackedSources>true</EmbedUntrackedSources>

		<!-- 
		Our nuget publication scripts will set the environment variable [NEON_PUBLIC_SOURCELINK=true]
		when the source code has been or will be commited to GitHub with the expectation that we'll
		enable sourcelink to reference source code from our GitHub repos.
		-->

		<ContinuousIntegrationBuild  Condition="'$(NEON_PUBLIC_SOURCELINK)' == 'true'">true</ContinuousIntegrationBuild>

	</PropertyGroup>

	<PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|AnyCPU'">
		<DefineConstants>$(DefineConstants);TRACE;DEBUG</DefineConstants>
		<Optimize>false</Optimize>
	</PropertyGroup>

	<PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|AnyCPU'">
		<Optimize>true</Optimize>
	</PropertyGroup>

	<!-- 
	$hack(jefflill):
	
	We've had a lot of trouble with auto generated source files generated for:
	
		* GitInfo
		* AssemblyInfoAttribute
		* TargetFrameworkAttribute
		
	The problem is that these are all generated in [obj/CONFIGURATION] or
	[obj/CONFIGURATION/TARGETFRAMEWORK] but the build system compiles all
	C# files it sees under the project directory, and it's very easy to 
	end up with multiple source files defining the same classes.
	
	We tried precleaning these files early in the build, but that didn't 
	work because we may end up building multiple build targets for the
	same project in parallel and it also prevented us from publishing
	nuget packages via scripts because we're typically running Visual
	Studio in the DEBUG build configuration but publishing as RELEASE.
	
	We also tried messing with the source input globbing rules, but
	that didn't work either.
	
	So here's what we're going to do:
	
		* Create a local [BuildInfo] library that has only one
		  build configuration and target framework.
		  
		* Have [BuildInfo] reference the GitInfo nuget package
		  and then write a drop-in replacement for the [ThisAssembly]
		  class that returns the values from the local GitInfo generated
		  class.
		  
		* Disable generation of the [AssemblyInfoAttribute] and 
		  [TargetFrameworkAttribute] classes for all projects.
		  
		* Manually add [AssemblyInfo.cs] and [AssemblyAttributes.cs]
		  classes to [BuildInfo] and reference these from other projects as
		  shared links.  This code will include #IFDEFs to compile the correct
		  code for the the current target framework, etc.
	-->
	
	<PropertyGroup>
		<GenerateAssemblyInfo>false</GenerateAssemblyInfo>
		<GenerateTargetFrameworkAttribute>false</GenerateTargetFrameworkAttribute>
	
		<DefineConstants Condition="'$(TargetFramework)' == 'netcoreapp3.1'">$(DefineConstants);TARGET_NETCORE_3_1</DefineConstants>
		<DefineConstants Condition="'$(TargetFramework)' == 'net5.0'">$(DefineConstants);TARGET_NETCORE_5_0</DefineConstants>
		<DefineConstants Condition="'$(TargetFramework)' == 'net6.0'">$(DefineConstants);TARGET_NETCORE_6_0</DefineConstants>
		<DefineConstants Condition="'$(TargetFramework)' == 'net7.0'">$(DefineConstants);TARGET_NETCORE_7_0</DefineConstants>
	
	</PropertyGroup>

</Project>
